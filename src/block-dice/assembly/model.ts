import { context, RNG, u128, PersistentMap, PersistentVector } from "near-sdk-as";
import { AccountID, FEE, GameID, Timestamp, Profile } from "../utils";

export const profiles = new PersistentMap<AccountID, Profile>("p");
export const games = new PersistentVector<Game>("g");
export const players = new PersistentMap<GameID, Player[]>("plys");


export enum GameStatus {
  CREATED,
  ACTIVE,
  COMPLETED,
}

export enum ClaimedWin {
  NO,
  CLAIMED,
}

@nearBindgen
export class Game {
  id: GameID;
  players: u32;
  prize: u128;
  started: Timestamp;
  ended: Timestamp;
  createdBy: string;
  createdAt: Timestamp;
  status: GameStatus;
  pool: u128;

  constructor() {
    this.createdBy = context.sender;
    this.players = 0;
    this.createdAt = context.blockTimestamp;
    this.status = GameStatus.CREATED;
    this.id = this.generateGameId();
  }

  //   Static method
  static getGameRules(): string {
    return "You need to create or join a game with a 0.05 NEAR fee \n A game starts when the first player rolls \n Each game lasts 30 minutes";
  }

  addNewPlayer(): void {
    this.players += 1;
    this.prize = u128.add(this.prize, FEE);
  }

  /**
   * Generates a new id and checks if ID already exists
   * if ID exists a new ID will be generated by calling the function again
   * @returns Game ID
   */
  private generateGameId(): GameID {
    const roll = new RNG<u32>(1, u32.MAX_VALUE);
    const id = context.blockTimestamp.toString() + "-" + roll.next().toString();

    return id;
  }

  canJoinGame(): bool {
    if (this.status !== GameStatus.COMPLETED) {
      if (this.status === GameStatus.ACTIVE && this.ended >= context.blockTimestamp) {
        return true;
      }
      return true;
    }
    return false;
  }

  canRollInGame(): bool {
    if (this.status !== GameStatus.COMPLETED) {
      if (this.status === GameStatus.ACTIVE && this.ended >= context.blockTimestamp) {
        return true;
      }
      return true;
    }
    return false;
  }
}

@nearBindgen
export class Player {
  roll1: u32;
  roll2: u32;
  timeJoined: Timestamp;
  timeRolled: Timestamp;
  claimedWin: ClaimedWin;
  constructor(public gameId: GameID, public playerId: AccountID) {
    this.timeJoined = context.blockTimestamp;
    this.claimedWin = ClaimedWin.NO;
  }

  sumDiceRoll(): u32 {
    return this.roll1 + this.roll2;
  }
}

@nearBindgen
export class GameReturnData {
  constructor(
    public data: Game[],
    public total: u32,
  ) {}
}
